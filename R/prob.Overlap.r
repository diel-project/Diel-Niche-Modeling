#' Kernel Overlap density integration
#'
#' @description Integrate kernel density to derive probability of twilight, daytime, nighttime
#' @param densityplot a densityPlot object from package overlap. See details for
#' additional information.
#' @param dawn beginning and end numeric (0-24) times for dawn. This is in
#' proportional hours such that 12.5 would be 12:30. See details for additional
#' information.
#' @param dusk beginning and end numeric (0-24) times for dusk. This is in
#' proportional hours such that 12.5 would be 12:30. See details for additional
#' information.
#' @return A matrix of three probabilities.
#' @details
#' When creating the density plot, it is important to increase the \code{n.grid}
#' argument, because to this function integrates the area under the curve to
#' compute the associated probabilities. We suggest to start setting \code{n.grid}
#'  in \code{overlap::densityPlot} to at least 10000, but you may be able to do
#'  less. Essentially, if the outputted sum is within about a thousandth from one
#'  (e.g., 0.999) then the output from this function can be used in 
#'  \code{\link{posthoc.niche}}.
#'  
#'  To compute proportional hours, you will need to start with a time object.
#'  Changing that time to a numeric should convert it to
#'  seconds from midnight. Given that there are 86,400 seconds in a day, divide
#'  by that number and multiply by 24 to create the proportional hours. See examples
#'  for some code on how to do this.
#'  
#'  @examples
#'  data("posthoc.example")
#'  
#'  diel_probs <- prob.overlap(
#'    posthoc.example$tiger.kde,
#'    dawn = posthoc.example$dawn.range,
#'    dusk = posthoc.example$dusk.range
#'  )
#'  
#' 
#' @export
#' @import sfsmisc

prob.overlap=function(densityplot,
                      dawn=c(6,7),
                      dusk=c(17,18)){

#########################
#Checks
  
  if(class(densityplot)=="actmod"){
    x.new <- seq(0,24,length.out=length(densityplot@pdf[,1]))
    densityplot=data.frame(x=x.new,y=densityplot@pdf[,2])
  }
  
  if(!is.data.frame(densityplot)  | ncol(densityplot)!=2 | any(colnames(densityplot)!=c("x","y"))| !is.numeric(densityplot$x) |  !is.numeric(densityplot$y)){
   stop("densityplot needs to be a dataframe with numeric values organized into two columns labled 'x' and 'y'") 
  }

  if(length(dawn)!=2 | length(dusk)!=2 | !is.numeric(dawn)| !is.numeric(dusk)){
   stop("dawn/dusk need to be vectors of length 2 with only numeric values")  
  }
  if(dawn[1] > dawn[2]){
    stop("the values of dawn should be the start and end of that diel period, in that order. The first value is currently greater than the second.")
  }
  if(dusk[1] > dusk[2]){
    stop("the values of dusk should be the start and end of that diel period, in that order. The first value is currently greater than the second.")
  }
    
#########################
  densityplot=densityplot[which(densityplot$x>=0 & densityplot$x<=24),]
  
  
  index.dawn=which(densityplot$x >= dawn[1] & densityplot$x<=dawn[2])
  index.dusk=which(densityplot$x>=dusk[1] & densityplot$x<=dusk[2])
  index.day=which(densityplot$x>dawn[2] & densityplot$x<dusk[1])
  index.night1=which(densityplot$x<dawn[1])
  index.night2=which(densityplot$x>dusk[2])
 
  if(length(index.dawn)==0){p.dawn=0}else{p.dawn=integrate.xy(densityplot$x[index.dawn],densityplot$y[index.dawn])}
  
  if(length(index.dusk)==0){p.dusk=0}else{p.dusk=integrate.xy(densityplot$x[index.dusk],densityplot$y[index.dusk])}
  
  if(length(index.day)==0){p.day=0}else{p.day=integrate.xy(densityplot$x[index.day],densityplot$y[index.day])}
  
  if(length(index.night1)==0){p.night1=0}else{p.night1=integrate.xy(densityplot$x[index.night1],densityplot$y[index.night1])}
  if(length(index.night2)==0){p.night2=0}else{p.night2=integrate.xy(densityplot$x[index.night2],densityplot$y[index.night2])}
  
  twi=p.dawn+p.dusk
  daytime=p.day
  nighttime=p.night1+p.night2
  
  y=t(matrix(c(twi,daytime,nighttime)))
  colnames(y)<-c("p.twi","p.day","p.night")
  
  # Check if the sum of y is within one thousandth of 1
  ysum <- sum(y)
  if(ysum < 0.999){
    warning(
      "The sum of the three probabilities generated by prob.overlap are not within one thousandth of 1. This could be because you did not sample enough grid points with overlap::densityPlot() or overlap::densityFit(). Try setting n.grid in those functions to 10000 and try using prob.overlap() again."
    )
    }
  
  y
  
}#End function
